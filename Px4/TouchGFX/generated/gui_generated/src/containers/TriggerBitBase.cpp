/*********************************************************************************/
/********** THIS FILE IS GENERATED BY TOUCHGFX DESIGNER, DO NOT MODIFY ***********/
/*********************************************************************************/
#include <gui_generated/containers/TriggerBitBase.hpp>
#include <string.h>
#include <string.h>


TriggerBitBase::TriggerBitBase() :
    timerTriggerBitTickCallback(this, &TriggerBitBase::timerTriggerBitTickCallbackHandler),
    timerTriggerBitBeginCallback(this, &TriggerBitBase::timerTriggerBitBeginCallbackHandler)
{
    setWidth(480);
    setHeight(272);
    hScreen.setXY(0, 0);
    hScreen.setVisible(false);

    timerTriggerBit.setXY(0, 0);
    timerTriggerBit.setVisible(false);
    timerTriggerBit.setTickCallback(timerTriggerBitTickCallback);
    timerTriggerBit.setBeginCallback(timerTriggerBitBeginCallback);

    add(hScreen);
    add(timerTriggerBit);
}

void TriggerBitBase::initialize()
{
    hScreen.initialize();
    timerTriggerBit.initialize();
}

void TriggerBitBase::timerTriggerBitTickCallbackHandler()
{
    //ChecarAtivacaoDeFlags
    //When timerTriggerBit tick execute C++ code
    //Execute C++ code
    if (W_HDW5000 != W_HDW5000_ANT){
    	W_HDW5000_ANT = W_HDW5000;
    	changeScreen(W_HDW5000);
    }
    else if (flag_congelar_SONDA){
    	flagCongelarSonda();
    }
    else if (Timer_Congelar_DECORRIDO_OUT){
        	timerCongelarDecorridoOut();
    }
    else if (Timer_BUzzer_OUT){
        	timerBuzzerOut();
    }
    else if (flag_congelar_Tempo){
        	flagCongelarTempo();
    }
    else if (cancelar_processo_SIM){
        	cancelarProcessoSim();
    }
    else if (Timer_buzzer_ON){
        	timerBuzzerOn();
    }
    else if (flag_Conservar_Cong_Resf){
        	flagConcervarCongResf();
    }
    else if (flag_resfriar_Sonda_tempo){
        	flagResfriarSondaTempo();
    }
    else if (flag_inicio_degelo){
        	flagInicioDegelo();
    }
    else if (flag_cancelar_degelo_SIM){
        	flagCancelarDegeloSim();
    }
    else if (flag_edit_receita){
        	flagEditReceita();
    }
    else if (flag_Receita1_interm){
        	flagReceita1Interm();
    }
    else if (flag_Receita2_interm){
           flagReceita2Interm();
    }
    else if (flag_Receita3_interm){
           flagReceita3Interm();
    }
    else if (flag_START_RECEITA){
        	flagStartReceita();
    }
    else if (flag_redefine_senha){
        	flagRedefineSenha();
    }
    else if (flag_alarme_externo){
        	flagAlarmeExterno();
    }
    else if (Timer_alarme_externo_OUT){
        	timerAlarmeExternoOut();
    }
    else if (W_1_4555 != 0){
    	entradaDigital3();
    }
    else if (Confere_senha){
        	confereSenha();
    }
    else if (reset_fabrica){
        	resetFabrica();
    }
    else if (start_higiene){
        	startHigiene();
    }
    else if (cancela_higiene){
        	cancelaHigiene();
    }
    else if (flag_Inicilizar_APLICACAO){
    	flagInicilizarAplicacao();
    }
    
    // Processo de degelo.
    if (Timer_BUzzer_DEG_OUT){
    	timerBuzzerDegOut();
    }
    if (Timer_buzzer_DEG_ON){
    	timerBuzzerDegOn();
    }
}

void TriggerBitBase::timerTriggerBitBeginCallbackHandler()
{
    //BeginTimerTriggerBit
    //When timerTriggerBit begin execute C++ code
    //Execute C++ code
    timerTriggerBit.setWaitTime(50);
    timerTriggerBit.start();
}

void TriggerBitBase::flagCongelarSonda()
{
    //flag_congelar_SONDA
    //When flagCongelarSonda is called execute C++ code
    //Execute C++ code
    //// MODO SONDA
    
    if (Status_tecla_Congela == 1){ 				//'if tela de Congelar SONDA
    	W_HDW5000 = 2;					//' Altera para tela de SONDA
    	//@W_1:410242 = @SP_SONDA_CONGELAR_CAMARA	//' SP = SP_SONDA_CONGELAR_CAMARA	
    	//@W_1:410282 = @Diferencial_Congelar_tempo	//' Diferencial rd=3ºC
    
    	Clear();
    	WriteModbus485(10242, 1);	
    	WriteModbus485(10282, 1);
    	WriteModbus485(645, 1);
    	
    	UpdateModbus485(10242, SP_SONDA_CONGELAR_CAMARA, _DOUBLE_);
    	UpdateModbus485(10242, SP_SONDA_CONGELAR_CAMARA, _DOUBLE_);
    	UpdateModbus485(10282, Diferencial_Congelar_tempo, _DOUBLE_);
    
    	//@W_1:4645 = 1				//' Controlador em modo COntrole
    
    	UpdateModbus485(645, 1, _DOUBLE_);
    		
    	Timer_Congelar_DECORRIDO_SP = 99999;	//' SP Timer- Inf
    	
    	Timer_Congelar_DECORRIDO_ON = 1;		//' START Timer TEmpo_COngelar_DECORRIDO_ON
    	flag_Processo_ANDAMENTO = 1;		//' Flag PRocesso_ANDAMENTO = TRUE
    	
    	Timer_delay_ON = 1;				//' Start Timer Delay
    }
    
    if (Status_tecla_Congela == 2){			//'tela de COngelar SELECT TEMPO
    	flag_alarm_receita_vazia = false; 	//' zera bit flag alarme de tempo Zero
    	W_HDW5000 = 4	;				//' Tela Select Tempo
    
    }
    
    
    flag_congelar_SONDA = false;
}

void TriggerBitBase::timerCongelarDecorridoOut()
{
    //Timer_Congelar_DECORRIDO_OUT
    //When timerCongelarDecorridoOut is called execute C++ code
    //Execute C++ code
    if (flag_Conservar_S_N == true){
    	flag_transicao_Conservar = true;		//' identifica quando há transição de congelar ou resfriar p/ COnservar
    	flag_Conservar_Cong_Resf = true;		//' flag_Conservar_Cong/Resf = 1
    //'else
    	//'@W_1:410242 = 999			//' SP = 99.9ºC
    	//'@W_1:4645 = 0				//' Controlador em Stand-By
    	//'@Timer_buzzer_ON = 1			//' inicia Timer_Buzzer
    }
    
    
    flag_Processo_ANDAMENTO = false; 		//' Zera flag_PROCESSO_ANDAMENTO
    Timer_Congelar_DECORRIDO_ON = 0;		//' Zera bit Timer_decorrido_ON
    
    Timer_buzzer_ON = 1;			//' inicia Timer_Buzzer
    
    Timer_delay_OUT = 0;			//' Zera Timer_delay_OUT
    
    
    Timer_Congelar_DECORRIDO_OUT = false;		//' Zera bit Timer_decorrido_OUT
}

void TriggerBitBase::timerBuzzerOut()
{
    //Timer_BUzzer_OUT
    //When timerBuzzerOut is called execute C++ code
    //Execute C++ code
    Clear();
    WriteModbus485(10242, 1);
    WriteModbus485(645, 1);
    WriteModbus485(10323, 1);
    
    if (flag_Conservar_S_N == false){
    	//@W_1:410242 = 999		//' SP = 99.9ºC
    	//@W_1:4645 = 0		//' Controlador em Stand-By
    	
    	UpdateModbus485(10242, 999, _DOUBLE_);			
    	UpdateModbus485(10242, 999, _DOUBLE_);
    	UpdateModbus485(645, 0, _DOUBLE_);
    }	
    
    
    //@W_1:410323 = 0			//' OUT4 = oF
    
    UpdateModbus485(10323, 0, _DOUBLE_);
    
    Timer_BUzzer_OUT = 0; 		//' Zera bi Timer_Buzzer_out
    
    Timer_buzzer_ON = 0;		//' Finaliza Timer_Buzzer
    
    Hard_Resf_fase_numero = 0;
    
    xBeep_once = false;
    
    
    
    flag_recuperar_leitura_dig = true;
    flag_recuperar_leitura_begin = true;
}

void TriggerBitBase::flagCongelarTempo()
{
    //flag_congelar_Tempo
    //When flagCongelarTempo is called execute C++ code
    //Execute C++ code
    //'''' MODO TEMPO
    Timer_Congelar_DECORRIDO_OUT = 0;			//' Zera bit Timer_decorrido_OUT
    
    
    if (Status_tecla_Congela == 2){ 			//'tela de COngelar TEMPO
    	if (Timer_SP_MINUTOS == 0)
    		flag_alarm_receita_vazia = 1;	//' flag alarm de timer em valor 0
    	else{	
    		W_HDW5000 = 3;			//' Tela Congelar Tempo
    		
    		Clear();
    		WriteModbus485(10242, 1);
    		WriteModbus485(10282, 1);
    		WriteModbus485(645, 1);
    		
    		Timer_Congelar_DECORRIDO_SP = Timer_SP_MINUTOS * 6; 	//' TRansforma SP minutos em seg10
    	
    		Timer_Congelar_DECORRIDO_ON = 1;				//' START Timer TEmpo_COngelar_DECORRIDO_ON
    		flag_Processo_ANDAMENTO = 1;				//' Flag PRocesso_ANDAMENTO = TRUE
    		
    		//@W_1:410242 = @SP_Congelar_Tempo			//' SP=-40
    		//@W_1:410282 = @Diferencial_Congelar_tempo		//' Diferencial rd=3ºC
    		//@W_1:4645 = 1						//' Controlador em modo COntrole
    				
    		UpdateModbus485(10242, SP_Congelar_Tempo, _DOUBLE_);
    		UpdateModbus485(10242, SP_Congelar_Tempo, _DOUBLE_);
    		UpdateModbus485(10282, Diferencial_Congelar_tempo, _DOUBLE_);
    		UpdateModbus485(645, 1, _DOUBLE_);
    	}
    }
    
    if (Status_tecla_Congela == 4){ 						//'tela de Resfriar TEMPO
    	if  (Timer_SP_MINUTOS_Resfriar == 0) 
    		flag_alarm_receita_vazia = 1;				//' flag alarm de timer em valor 0
    	else{
    		
    		Clear();
    		WriteModbus485(10242, 1);
    		WriteModbus485(10282, 1);
    		WriteModbus485(645, 1);
    
    		if (flag_Resfriar_HARD_SOFT == 0){			//' if SOFT
    		//'	@W_1:410242 = @SP_Resfriar_Tempo_SOFT		//' SP_Controlador = SP Resfriar SOFT
    			//@W_1:410242 = @SP_SONDA_RESF_CAMARA
    			
    			SP_Resf_Hard_Interno_display = SP_Resfriar_Tempo_SOFT;
    			//@W_1:410282 = @Diferencial_Resfriar_Tempo		//' Diferencial rd
    					
    			UpdateModbus485(10242, SP_SONDA_RESF_CAMARA, _DOUBLE_);
    			UpdateModbus485(10242, SP_SONDA_RESF_CAMARA, _DOUBLE_);
    			UpdateModbus485(10282, Diferencial_Resfriar_Tempo, _DOUBLE_);
    		
    		}
    		else{ //' if HARD
    			//'@W_1:410242 = @SP_Resfriar_Tempo_HARD			//' SP_Controlador = SP Resfriar HARD 
    
    			Hard_Resf_fase_numero = 1; //' Resfriamento por etapas - Etapa =1
    
    			Dif_Resf_Hard_F1 = Diferencial_Resfriar_Tempo;
    			Dif_Resf_Hard_F2 = Dif_Resf_Hard_F1;
    
    			//@W_1:410242 = @SP_Resf_Interno_F1 
    			//@W_1:410282 = @Dif_Resf_Hard_F1					//' Diferencial de controle para modo Delicado Sonda
    							
    			UpdateModbus485(10242, SP_Resf_Interno_F1, _DOUBLE_);
    			UpdateModbus485(10242, SP_Resf_Interno_F1, _DOUBLE_);
    			UpdateModbus485(10282, Dif_Resf_Hard_F1, _DOUBLE_);		
    	
    			SP_Resf_Hard_Interno_display =  SP_Resf_Interno_F1;
    						
    			Preset_Resf_Tempo_F1 = Timer_SP_MINUTOS_Resfriar * 6; 	//' transforma Sp minutos em seg*10
    			Preset_Resf_Tempo_F1 = Preset_Resf_Tempo_F1 *  Porc_Resf_preset_tempo_F1F2;
    			Preset_Resf_Tempo_F1 = Preset_Resf_Tempo_F1 / 10;
    
    			Preset_Resf_Tempo_F2 = Timer_SP_MINUTOS_Resfriar * 6 - Preset_Resf_Tempo_F1;
    
    			SP_Resf_Interno_F2 = SP_SONDA_RESF_CAMARA;
    			xBeep_once = false;	
    			
    		}
    		
    		Timer_Congelar_DECORRIDO_SP = Timer_SP_MINUTOS_Resfriar * 6; 	//' TRansforma SP minutos em seg10
    		//@W_1:4645 = 1								//' Controlador em modo COntrole
    		
    		UpdateModbus485(645, 1, _DOUBLE_);
    
    		Timer_Congelar_DECORRIDO_ON = 1;				//' START Timer TEmpo_COngelar_DECORRIDO_ON
    		flag_Processo_ANDAMENTO = true;				//' Flag PRocesso_ANDAMENTO = TRUE
    		W_HDW5000 = 13;						//'tela de Resfriar TEMPO
    		
    	}
    }
    
    
    flag_congelar_Tempo = false;
}

void TriggerBitBase::cancelarProcessoSim()
{
    //cancelar_processo_SIM
    //When cancelarProcessoSim is called execute C++ code
    //Execute C++ code
    if (flag_Processo_ANDAMENTO == true){
    
    	if (Status_tecla_Congela == 0){ 		//' Modo COngelar Sonda
    
    		Clear();
    		WriteModbus485(10242, 1);
    		WriteModbus485(645, 1);
    		
    		flag_Processo_ANDAMENTO = false; 	//' Zera flag_PROCESSO_ANDAMENTO
    		//@W_1:410242 = 999			//' SP = 99.9ºC
    		//@W_1:4645 = 0			//' Controlador em Stand-By
    			
    		W_HDW5000 = 19;			//' Tela Receita
    			
    		UpdateModbus485(10242, 999, _DOUBLE_);
    		UpdateModbus485(10242, 999, _DOUBLE_);
    		UpdateModbus485(645, 0, _DOUBLE_);		
    			
    		Timer_Congelar_DECORRIDO_ON = 0;	//' Zera bit Timer_decorrido_ON
    	}	
    
    	if (Status_tecla_Congela == 1){ 		//' Modo COngelar Sonda
    
    		Clear();
    		WriteModbus485(10242, 1);
    		WriteModbus485(645, 1);
    
    		flag_Processo_ANDAMENTO = false; 	//' Zera flag_PROCESSO_ANDAMENTO
    		//@W_1:410242 = 999			//' SP = 99.9ºC
    		//@W_1:4645 = 0			//' Controlador em Stand-By
    			
    		W_HDW5000 = 1;			//' Tela Congelar Sonda
    		
    		UpdateModbus485(10242, 999, _DOUBLE_);
    		UpdateModbus485(10242, 999, _DOUBLE_);
    		UpdateModbus485(645, 0, _DOUBLE_);		
    			
    		Timer_Congelar_DECORRIDO_ON = 0;	//' Zera bit Timer_decorrido_ON	
    		
    	}
    
    	if (Status_tecla_Congela == 2){ 		//' Modo COngelar Tempo
    
    		Clear();
    		WriteModbus485(10242, 1);
    		WriteModbus485(645, 1);
    
    		flag_Processo_ANDAMENTO = false; 	//' Zera flag_PROCESSO_ANDAMENTO
    		//@W_1:410242 = 999			//' SP = 99.9ºC
    		//@W_1:4645 = 0			//' Controlador em Stand-By
    		
    		W_HDW5000 = 1;	
    		
    		UpdateModbus485(10242, 999, _DOUBLE_);
    		UpdateModbus485(10242, 999, _DOUBLE_);
    		UpdateModbus485(645, 0, _DOUBLE_);			
    
    		Timer_Congelar_DECORRIDO_ON = 0;	//' Zera bit Timer_decorrido_ON	
    	}
    
    	if (Status_tecla_Congela == 3){ 		//' Modo Resfriar Sonda
    
    		Clear();		
    		WriteModbus485(640, 1);
    		WriteModbus485(10242, 1);
    		WriteModbus485(645, 1);
    
    		flag_Processo_ANDAMENTO = false; 	//' Zera flag_PROCESSO_ANDAMENTO
    		//@W_1:4640 = 0			//' Desliga Modo Turbo
    		//@W_1:410242 = 999			//' SP = 99.9ºC
    		//@W_1:4645 = 0			//' Controlador em Stand-By
    		
    		W_HDW5000 = 10;		
    		
    		UpdateModbus485(640, 0, _DOUBLE_);
    		UpdateModbus485(10242, 999, _DOUBLE_);
    		UpdateModbus485(645, 0, _DOUBLE_);
    					
    		Timer_Congelar_DECORRIDO_ON = 0;	//' Zera bit Timer_decorrido_ON	
    	}
    
    	if (Status_tecla_Congela == 4){ 		//' Modo Resfriar Tempo
    
    		Clear();
    		WriteModbus485(10242, 1);
    		WriteModbus485(645, 1);
    
    		flag_Processo_ANDAMENTO = false; 	//' Zera flag_PROCESSO_ANDAMENTO
    		//@W_1:410242 = 999			//' SP = 99ºC
    		//@W_1:4645 = 0			//' Controlador em Stand-By
    		
    		W_HDW5000 = 10;
    		
    		UpdateModbus485(10242, 999, _DOUBLE_);
    		UpdateModbus485(10242, 999, _DOUBLE_);
    		UpdateModbus485(645, 0, _DOUBLE_);			
    		
    		Timer_Congelar_DECORRIDO_ON = 0;	//' Zera bit Timer_decorrido_ON
    	}
    
    	flag_Processo_ANDAMENTO = false;
    
    	//'@Timer_buzzer_ON = 1			//' inicia Timer_Buzzer
    }
    else{ 
    	if (Status_tecla_Congela == 0){   					//'if Receita Temperatura
    		W_HDW5000=19;							//' Tela_Receita Temperatura
    	}						
    	if (Status_tecla_Congela == 1 || Status_tecla_Congela == 2){ 	//'if Congelar_SONDA ou Congelar_Tempo
    		W_HDW5000=1;							//' Tela_Congelar
    	}
    	if (Status_tecla_Congela == 3 || Status_tecla_Congela == 4){	//' if @Status_tecla_Congela=3 or @Status_tecla_Congela=4
    		W_HDW5000=10;							//' Tela_Resfriar
    	}
    
    }
    
    if (flag_Conservar_ANDAMENTO == true){
    	if (Status_Conservar == 1){		//' Conservar_Congelar
    		W_HDW5000 = 7;			//' Tela Conservar
    		//@W_1:410242 = 999			//' SP = 99ºC
    		//@W_1:4645 = 0			//' Controlador em modo Standby
    
    		Clear();
    		WriteModbus485(10242, 1);
    		WriteModbus485(645, 1);		
    
    		UpdateModbus485(10242, 999, _DOUBLE_);
    		UpdateModbus485(10242, 999, _DOUBLE_);
    		UpdateModbus485(645, 0, _DOUBLE_);
    	}
    	
    	if (Status_Conservar == 2){ 		//' Consewrvar_Resfriar
    		W_HDW5000 = 7;			//' Tela COnservar
    		//@W_1:410242 = 999			//' SP = 99ºC
    		//@W_1:4645 = 0			//' Controlador em modo Stand-by
    
    		Clear();
    		WriteModbus485(10242, 1);
    		WriteModbus485(645, 1);	
    		
    		UpdateModbus485(10242, 999, _DOUBLE_);
    		UpdateModbus485(10242, 999, _DOUBLE_);
    		UpdateModbus485(645, 0, _DOUBLE_);	
    	}
    	
    	flag_Conservar_ANDAMENTO = false;		//' Zera flag_conservar_andamento
    
    	//'@Timer_buzzer_ON = 1			//' inicia Timer_Buzzer
    }
    
    Timer_delay_OUT = 0;				//' Zera Timer_delay_OUT
    
    cancelar_processo_SIM = false; 			//' Zera bit cancelar_processo_SIM
}

void TriggerBitBase::timerBuzzerOn()
{
    //Timer_buzzer_ON
    //When timerBuzzerOn is called execute C++ code
    //Execute C++ code
    //@W_1:410323 = 11		//' OUT4 = on
    
    UpdateModbus485(10323, 11, _DOUBLE_);
    
    //Beep()
    SoundBuzzerOn(100);
}

void TriggerBitBase::flagConcervarCongResf()
{
    //flag_Conservar_Cong_Resf
    //When flagConcervarCongResf is called execute C++ code
    //Execute C++ code
    if (Status_tecla_Congela == 0){				//' Se Modo Receita_Temperatura
    	if (Receita_Cong_Resf_ATUAL == 0){		//' Modo COngelar da Receita
    		Status_tecla_Congela = 2;
    	}
    	if (Receita_Cong_Resf_ATUAL == 1){		//' Modo Resfriar da Receita
    		Status_tecla_Congela = 4;
    	}
    }
    
    
    if (flag_transicao_Conservar == 1){					//' Entra automaticamente em Conservar de Congelar ou Resfriar
    	if (Status_tecla_Congela == 1 || Status_tecla_Congela == 2){
    		Status_Conservar = 1;					//' COnservar_COngelar			
    	}
    	else{									//' @Status_tecla_Congela=3 or @Status_tecla_Congela=4
    		Status_Conservar = 2;					//' COnservar_resfriar
    	}
    }
    
    flag_transicao_Conservar = false;						//' zera bit transição
    
    
    if (Status_Conservar == 1){						//' if COnservar_Congelar=1
    	W_HDW5000=8;							//' vai para tela Conservar_COngelar
    	//@W_1:410242 = @SP_Conservar_Congelar				//' SP= Conservar Congelar 
    	//@W_1:410282 = @Diferencial_Conservar_COngelar		//' Diferencial rd
    	//@W_1:4645 = 1							//' Controlador em modo COntrole
    	
    	Clear();
    	WriteModbus485(10242, 1);
    	WriteModbus485(10282, 1);
    	WriteModbus485(645, 1);	
    	
    	UpdateModbus485(10242, SP_Conservar_Congelar, _DOUBLE_);
    	UpdateModbus485(10242, SP_Conservar_Congelar, _DOUBLE_);
    	UpdateModbus485(10282, Diferencial_Conservar_COngelar, _DOUBLE_);
    	UpdateModbus485(645, 1, _DOUBLE_);
    
    }		
    else{
    	W_HDW5000=9;							//' vai para tela Conservar_COngelar
    	//@W_1:410242 = @SP_Conservar_Resfriar				//' SP= COnservar Resfriar
    	//@W_1:410282 = @Diferencial_Conservar_Resfriar		//' Diferencial rd=3ºC
    	//@W_1:4645 = 1							//' Controlador em modo COntrole
    
    	Clear();
    	WriteModbus485(10242, 1);
    	WriteModbus485(10282, 1);	
    	WriteModbus485(645, 1);	
    	
    	UpdateModbus485(10242, SP_Conservar_Resfriar, _DOUBLE_);
    	UpdateModbus485(10242, SP_Conservar_Resfriar, _DOUBLE_);
    	UpdateModbus485(10282, Diferencial_Conservar_Resfriar, _DOUBLE_);
    	UpdateModbus485(645, 1, _DOUBLE_);
    
    }
    
    flag_Conservar_ANDAMENTO = true;			//' flag_conservar_ANDAMENTO=1
    
    flag_Conservar_Cong_Resf = false; 		//' zera bit
}

void TriggerBitBase::flagResfriarSondaTempo()
{
    //flag_resfriar_Sonda_tempo
    //When flagResfriarSondaTempo is called execute C++ code
    //Execute C++ code
    //'''' MODO SONDA
    
    if (Status_tecla_Congela == 3){	 				//' if tela de REsfriar SONDA
    
    	Clear();
    	WriteModbus485(10242, 1);
    	WriteModbus485(10282, 1);	
    	WriteModbus485(645, 1);
    	
    	if (flag_Resfriar_HARD_SOFT == false){ 			//' SE MODO SOFT
    
    		//@W_1:410242= @SP_SONDA_RESF_CAMARA 		//' SP = RESF MODO SSONDA
    		//@W_1:410282 = @Diferencial_Resfriar_Tempo	//' Diferencial rd	
    		
    		UpdateModbus485(10242, SP_SONDA_RESF_CAMARA, _DOUBLE_);
    		UpdateModbus485(10242, SP_SONDA_RESF_CAMARA, _DOUBLE_);
    		UpdateModbus485(10282, Diferencial_Resfriar_Tempo, _DOUBLE_);		
    
    		SP_Resf_Hard_Interno_display = SP_SONDA_RESF_CAMARA;
    		SP_Resf_Hard_Espeto_display = SP_Resfriar_Sonda;
    	}
    	else{ //' SE MODO HARD
    		Hard_Resf_fase_numero = 1; 			//' Resfriamento por etapas - Etapa =1
    		
    	
    		Dif_Resf_Hard_F1 = Diferencial_Resfriar_Tempo;
    		Dif_Resf_Hard_F2 = Dif_Resf_Hard_F1;
    
    		//@W_1:410242 = @SP_Resf_Interno_F1		//' SP X34 = SP_Interno_F1_controle
    		//@W_1:410282 = @Dif_Resf_Hard_F1			//' Diferencial de controle para modo Delicado Sonda
    		
    		UpdateModbus485(10242, SP_Resf_Interno_F1, _DOUBLE_);	
    		UpdateModbus485(10242, SP_Resf_Interno_F1, _DOUBLE_);	
    		UpdateModbus485(10282, Dif_Resf_Hard_F1, _DOUBLE_);		
    
    		SP_Resf_Espeto_F2 = SP_Resfriar_Sonda;
    		SP_Resf_Interno_F2 = SP_SONDA_RESF_CAMARA;		
    
    
    		SP_Resf_Hard_Interno_display = SP_Resf_Interno_F1;
    		SP_Resf_Hard_Espeto_display = SP_Resf_Espeto_F1;	
    
    
    	}
    	
    	Timer_Congelar_DECORRIDO_SP = 99999;	//' SP Timer- Inf
    	
    	Timer_Congelar_DECORRIDO_ON = 1;		//' START Timer TEmpo_REsfriar_DECORRIDO_ON
    	flag_Processo_ANDAMENTO = true;		//' Flag PRocesso_ANDAMENTO = TRUE
    
    	Timer_delay_ON = 1;				//' Start Timer Delay
    
    	//@W_1:4645 = 1				//' Controlador em modo COntrole
    	W_HDW5000 = 11;				//' Altera para tela de Resfriar SONDA
    
    	UpdateModbus485(645, 1, _DOUBLE_);
    }
    
    //'''' MODO Tempo
    
    if (Status_tecla_Congela == 4){			//'tela de REsfriar SELECT TEMPO
    	flag_alarm_receita_vazia = false;		//' zera bit flag alarme de tempo Zero
    	W_HDW5000 = 12;				//' Tela Resfriar modo Tempo
    }
    
    flag_resfriar_Sonda_tempo = false	;		//' Zera bit flag_congelar_tecla_play
}

void TriggerBitBase::flagInicioDegelo()
{
    //flag_inicio_degelo
    //When flagInicioDegelo is called execute C++ code
    //Execute C++ code
    
    if  (degelo_porta_aberta == true){
    
    	if  (Status_Porta == false){		//' Status Porta = 0
    		W_HDW5000=15;				//' Retorna tela Degelo_confirmar
    	}
    	else{						//' Status Porta = 1
    		Clear();
    		WriteModbus485(10299, 1);
    		WriteModbus485(10256, 1);
    		WriteModbus485(10242, 1);
    		WriteModbus485(645, 1);
    		WriteModbus485(641, 1);	
    
    		//@delay_comp = @W_1:410299 	//' armazena Pod
    		//@W_1:410299 = 1			//' POD = oF
    		
    		delay_comp = W_1_410299;
    		UpdateModbus485(10299, 1, _DOUBLE_);
    	
    		//@W_1:410256 = 1 * @logica_entrada_digital1	//' i.F1 = Entrada Digital 1 > Porta (NA = porta fechada) Não influencia no ventilador
    		//@W_1:410242 = 999			//' SP = 99ºC
    		//@W_1:4645 = 1			//' Controlador em modo COntrole
    		//@W_1:4641 = 1			//' Start Degelo
    	
    		UpdateModbus485(10256, 1 * logica_entrada_digital1, _DOUBLE_);
    		UpdateModbus485(10242, 999, _DOUBLE_);
    		UpdateModbus485(645, 1, _DOUBLE_);
    		UpdateModbus485(641, 1, _DOUBLE_);
    	
    		flag_degelo_andamento = true; 	//' Flag degelo em andamento=1
    	
    		Timer_Degelo_ON = 1;		//' inicio Timer Degelo (contagem indicativa)
    		Timer_Degelo_CONTROL = 1;		//' timer_degelo_control=1
    		Timer_degelo_delay_ON = 1;		//' inicio Timer_degelo_delay
    		Timer_degelo_delay_OUT = 0;	//' zera bit Timer_degelo_delay_OUT
    
    		W_HDW5000=14;				//' Tela Degelo
    	}
    }
    else{
    	Clear();
    
    	WriteModbus485(10299, 1);
    	WriteModbus485(10256, 1);
    	WriteModbus485(10242, 1);
    	WriteModbus485(645, 1);
    	WriteModbus485(641, 1);
    	
    	//@delay_comp = @W_1:410299 			//' armazena Pod
    	//@W_1:410299 = 1					//' POD = oF
    
    	delay_comp = W_1_410299;
    	UpdateModbus485(10299, 1, _DOUBLE_);
    	
    	//@W_1:410256 = 1 * @logica_entrada_digital1	//' i.F1 = Entrada Digital 1 > Porta (NA = porta fechada) Não influencia no ventilador
    	//@W_1:410242 = 999			//' SP = 99ºC
    	//@W_1:4645 = 1			//' Controlador em modo COntrole
    	//@W_1:4641 = 1			//' Start Degelo
    
    	UpdateModbus485(10256, 1 * logica_entrada_digital1, _DOUBLE_);
    	UpdateModbus485(10242, 999, _DOUBLE_);
    	UpdateModbus485(645, 1, _DOUBLE_);
    	UpdateModbus485(641, 1, _DOUBLE_);
    	
    	flag_degelo_andamento = true; 	//' Flag degelo em andamento=1
    	
    	Timer_Degelo_ON = 1;		//' inicio Timer Degelo (contagem indicativa)
    	Timer_Degelo_CONTROL = 1;		//' timer_degelo_control=1
    	Timer_degelo_delay_ON = 1;		//' inicio Timer_degelo_delay
    	Timer_degelo_delay_OUT = 0;	//' zera bit Timer_degelo_delay_OUT
    
    	W_HDW5000=14;				//' Tela Degelo
    
    }
    
    
    flag_inicio_degelo = false;		//' Zera bit flag_inicio_degelo
}

void TriggerBitBase::flagCancelarDegeloSim()
{
    //flag_cancelar_degelo_SIM
    //When flagCancelarDegeloSim is called execute C++ code
    //Execute C++ code
    Clear();
    
    WriteModbus485(10299, 1);
    WriteModbus485(10256, 1);
    WriteModbus485(10242, 1);
    WriteModbus485(645, 1);
    
    //'' Cancelar Degelo
    
    W_HDW5000=15;					//' Tela Degelo_confirmar
    
    Status_degelo = 0;			    		//' Desliga Degelo
    flag_degelo_andamento = false; 			//' Flag degelo em andamento=0
    
    //@W_1:410242 = 999					//' SP = 99ºC
    //@W_1:4645 = 0					//' Controlador em modo Stand-BY
    //@W_1:410256 = 2 * @logica_entrada_digital1	//' i.F1 = Entrada Digital 1 > Porta com parada ventilador (NA = porta fechada)
    
    
    //@W_1:410299 = @delay_comp			//' POD = oF
    
    UpdateModbus485(10242, 999, _DOUBLE_);
    UpdateModbus485(10242, 999, _DOUBLE_);
    UpdateModbus485(645, 0, _DOUBLE_);
    UpdateModbus485(10256, 2 * logica_entrada_digital1, _DOUBLE_);
    
    UpdateModbus485(10299, delay_comp, _DOUBLE_);
    
    Timer_degelo_delay_ON = 0;				//' Timer Degelo Delay ON = 0
    Timer_degelo_delay_OUT = 0;			//' Timer_degelo_delay_OUT=0
    Timer_Degelo_CONTROL = 0;				//' timer_degelo_control=0
    Timer_Degelo_ON = 0;				//' Timer Degelo ON =0
    Timer_Degelo_OUT = 0;
    
    flag_cancelar_degelo_SIM = false;			//'Zera bit flag_canelar_degelo_SIM
}

void TriggerBitBase::flagEditReceita()
{
    //flag_edit_receita
    //When flagEditReceita is called execute C++ code
    //Execute C++ code
    if (numero_receita == 1)		//'seleciona tela edição receita 1
    	W_HDW5000 = 22;
    
    if (numero_receita == 2)		//'seleciona tela edição receita 2
    	W_HDW5000 = 23;
    
    if (numero_receita == 3)		//'seleciona tela edição receita 3
    	W_HDW5000 = 24;
    
    if (numero_receita == 4)		//'seleciona tela edição receita 4
    	W_HDW5000 = 25;
    
    if (numero_receita == 5)		//'seleciona tela edição receita 5
    	W_HDW5000 = 26;
    
    if (numero_receita == 6)		//'seleciona tela edição receita 6
    	W_HDW5000 = 27;
    
    if (numero_receita == 7)		//'seleciona tela edição receita 7
    	W_HDW5000 = 28;
    
    if (numero_receita == 8)		//'seleciona tela edição receita 8
    	W_HDW5000 = 29;
    
    if (numero_receita == 9)		//'seleciona tela edição receita 9
    	W_HDW5000 = 30;
    
    if (numero_receita == 10)		//'seleciona tela edição receita 10
    	W_HDW5000 = 31;
    
    if (numero_receita == 11)		//'seleciona tela edição receita 11
    	W_HDW5000 = 32;
    
    if (numero_receita == 12)		//'seleciona tela edição receita 12
    	W_HDW5000 = 33;
    
    
    flag_edit_receita = false;   //'zera bit flag
}

void TriggerBitBase::flagReceita1Interm()
{
    //flag_Receita1_interm
    //When flagReceita1Interm is called execute C++ code
    //Execute C++ code
    flag_alarm_receita_vazia = false;					//' zera bit flag de alarme de receita tempo em zero
    
    if (numero_receita == 1){						//' Muda de tela de a receita da tela atual for selecinada
    	Tempo_Receita_ATUAL = Tempo_receita_1;			//' Atualiza o tempo de receita atual = Tempo receita 1
    	Receita_Cong_Resf_ATUAL = R1_cong_resf;			//' Atualiza Se a receita atual é Congelar ou Resfriar
    	Receita_Hard_Soft_ATUAL = R1_Hard_Soft;			//' Atualiza se em resfriar é Hard ou Soft
    	Receita_Conserv_ATUAL = R1_Conserv_yn;			//' Atualiza se após receita vai autom. para conservação
    	
    	Temperatura_Receita_ATUAL = Temperatura_receita_01;	//' Atualiza a temperatura receita Atual = temperatura da receita 1
    	Receita_time_temp_ATUAL = R1_time_temp;			//' Atualiza escolha de finalização por tempo ou temperatura
    
    	W_HDW5000 = 34;						//' Vai para a tela Receita_confirm
    }	
    
    if (numero_receita == 2){						//' Muda de tela de a receita da tela atual for selecinada
    	Tempo_Receita_ATUAL = Tempo_receita_2;			//' ver receita 1
    	Receita_Cong_Resf_ATUAL = R2_cong_resf;			//' ver receita 1
    	Receita_Hard_Soft_ATUAL = R2_Hard_Soft;			//' ver receita 1
    	Receita_Conserv_ATUAL = R2_Conserv_yn;			//' ver receita 1
    
    	Temperatura_Receita_ATUAL = Temperatura_receita_02;	//' ver receita 1
    	Receita_time_temp_ATUAL = R2_time_temp;			//' ver receita 1
    
    	W_HDW5000 = 34;						//' Vai para a tela Receita_confirm
    }
    
    if (numero_receita == 3){						//' Muda de tela de a receita da tela atual for selecinada
    	Tempo_Receita_ATUAL = Tempo_receita_3; 			//'' ver receita 1
    	Receita_Cong_Resf_ATUAL = R3_cong_resf;			//' ver receita 1
    	Receita_Hard_Soft_ATUAL = R3_Hard_Soft;			//' ver receita 1
    	Receita_Conserv_ATUAL = R3_Conserv_yn;			//' ver receita 1
    
    	Temperatura_Receita_ATUAL = Temperatura_receita_03;	//' ver receita 1
    	Receita_time_temp_ATUAL = R3_time_temp;			//' ver receita 1
    	
    	W_HDW5000 = 34;						//' Vai para a tela Receita_confirm
    }
    
    if (numero_receita == 4){						//' Muda de tela de a receita da tela atual for selecinada
    	Tempo_Receita_ATUAL = Tempo_receita_4;
    	Receita_Cong_Resf_ATUAL = R4_cong_resf;
    	Receita_Hard_Soft_ATUAL = R4_Hard_Soft;
    	Receita_Conserv_ATUAL = R4_Conserv_yn;
    
    	Temperatura_Receita_ATUAL = Temperatura_receita_04;	//' ver receita 1
    	Receita_time_temp_ATUAL = R4_time_temp;			//' ver receita 1
    	
    	W_HDW5000 = 34;						//' Vai para a tela Receita_confirm
    }
    
    flag_Receita1_interm = false; 					//' zera bit flag
}

void TriggerBitBase::flagReceita2Interm()
{
    //flag_Receita2_interm
    //When flagReceita2Interm is called execute C++ code
    //Execute C++ code
    flag_alarm_receita_vazia = false;					//' zera bit flag de alarme de receita tempo em zero
    
    if (numero_receita == 5){						//' Muda de tela de a receita da tela atual for selecinada
    	Tempo_Receita_ATUAL = Tempo_receita_5;			//' Atualiza o tempo de receita atual = Tempo receita 1
    	Receita_Cong_Resf_ATUAL = R5_cong_resf;			//' Atualiza Se a receita atual é Congelar ou Resfriar
    	Receita_Hard_Soft_ATUAL = R5_Hard_Soft;			//' Atualiza se em resfriar é Hard ou Soft
    	Receita_Conserv_ATUAL = R5_Conserv_yn;			//' Atualiza se após receita vai autom. para conservação
    	
    	Temperatura_Receita_ATUAL = Temperatura_receita_05;	//' Atualiza a temperatura receita Atual = temperatura da receita 1
    	Receita_time_temp_ATUAL = R5_time_temp;			//' Atualiza escolha de finalização por tempo ou temperatura
    
    	W_HDW5000 = 34;						//' Vai para a tela Receita_confirm
    }	
    
    if (numero_receita == 6){						//' Muda de tela de a receita da tela atual for selecinada
    	Tempo_Receita_ATUAL = Tempo_receita_6;			//' ver receita 1
    	Receita_Cong_Resf_ATUAL = R6_cong_resf;			//' ver receita 1
    	Receita_Hard_Soft_ATUAL = R6_Hard_Soft;			//' ver receita 1
    	Receita_Conserv_ATUAL = R6_Conserv_yn;			//' ver receita 1
    
    	Temperatura_Receita_ATUAL = Temperatura_receita_06;	//' ver receita 1
    	Receita_time_temp_ATUAL = R6_time_temp;			//' ver receita 1
    
    	W_HDW5000 = 34;						//' Vai para a tela Receita_confirm
    }
    
    if (numero_receita == 7){						//' Muda de tela de a receita da tela atual for selecinada
    	Tempo_Receita_ATUAL = Tempo_receita_7; 			//'' ver receita 1
    	Receita_Cong_Resf_ATUAL = R7_cong_resf;			//' ver receita 1
    	Receita_Hard_Soft_ATUAL = R7_Hard_Soft;			//' ver receita 1
    	Receita_Conserv_ATUAL = R7_Conserv_yn;			//' ver receita 1
    
    	Temperatura_Receita_ATUAL = Temperatura_receita_07;	//' ver receita 1
    	Receita_time_temp_ATUAL = R7_time_temp;			//' ver receita 1
    	
    	W_HDW5000 = 34;						//' Vai para a tela Receita_confirm
    }
    
    if (numero_receita == 8){						//' Muda de tela de a receita da tela atual for selecinada
    	Tempo_Receita_ATUAL = Tempo_receita_8;
    	Receita_Cong_Resf_ATUAL = R8_cong_resf;
    	Receita_Hard_Soft_ATUAL = R8_Hard_Soft;
    	Receita_Conserv_ATUAL = R8_Conserv_yn;
    
    	Temperatura_Receita_ATUAL = Temperatura_receita_08;	//' ver receita 1
    	Receita_time_temp_ATUAL = R8_time_temp;			//' ver receita 1
    	
    	W_HDW5000 = 34;						//' Vai para a tela Receita_confirm
    }
    
    flag_Receita2_interm = false; 					//' zera bit flag
}

void TriggerBitBase::flagReceita3Interm()
{
    //flag_Receita3_interm
    //When flagReceita3Interm is called execute C++ code
    //Execute C++ code
    flag_alarm_receita_vazia = false;					//' zera bit flag de alarme de receita tempo em zero
    
    if (numero_receita == 9){						//' Muda de tela de a receita da tela atual for selecinada
    	Tempo_Receita_ATUAL = Tempo_receita_9;			//' Atualiza o tempo de receita atual = Tempo receita 1
    	Receita_Cong_Resf_ATUAL = R9_cong_resf;			//' Atualiza Se a receita atual é Congelar ou Resfriar
    	Receita_Hard_Soft_ATUAL = R9_Hard_Soft;			//' Atualiza se em resfriar é Hard ou Soft
    	Receita_Conserv_ATUAL = R9_Conserv_yn;			//' Atualiza se após receita vai autom. para conservação
    	
    	Temperatura_Receita_ATUAL = Temperatura_receita_09;	//' Atualiza a temperatura receita Atual = temperatura da receita 1
    	Receita_time_temp_ATUAL = R9_time_temp;			//' Atualiza escolha de finalização por tempo ou temperatura
    
    	W_HDW5000 = 34;						//' Vai para a tela Receita_confirm
    }	
    
    if (numero_receita == 10){						//' Muda de tela de a receita da tela atual for selecinada
    	Tempo_Receita_ATUAL = Tempo_receita_10;			//' ver receita 1
    	Receita_Cong_Resf_ATUAL = R10_cong_resf;		//' ver receita 1
    	Receita_Hard_Soft_ATUAL = R10_Hard_Soft;		//' ver receita 1
    	Receita_Conserv_ATUAL = R10_Conserv_yn;			//' ver receita 1
    
    	Temperatura_Receita_ATUAL = Temperatura_receita_10;	//' ver receita 1
    	Receita_time_temp_ATUAL = R10_time_temp;		//' ver receita 1
    
    	W_HDW5000 = 34;						//' Vai para a tela Receita_confirm
    }
    
    if (numero_receita == 11){						//' Muda de tela de a receita da tela atual for selecinada
    	Tempo_Receita_ATUAL = Tempo_receita_11; 		//'' ver receita 1
    	Receita_Cong_Resf_ATUAL = R11_cong_resf;		//' ver receita 1
    	Receita_Hard_Soft_ATUAL = R11_Hard_Soft;		//' ver receita 1
    	Receita_Conserv_ATUAL = R11_Conserv_yn;			//' ver receita 1
    
    	Temperatura_Receita_ATUAL = Temperatura_receita_11;	//' ver receita 1
    	Receita_time_temp_ATUAL = R11_time_temp;		//' ver receita 1
    	
    	W_HDW5000 = 34;						//' Vai para a tela Receita_confirm
    }
    
    if (numero_receita == 12){						//' Muda de tela de a receita da tela atual for selecinada
    	Tempo_Receita_ATUAL = Tempo_receita_12;
    	Receita_Cong_Resf_ATUAL = R12_cong_resf;
    	Receita_Hard_Soft_ATUAL = R12_Hard_Soft;
    	Receita_Conserv_ATUAL = R12_Conserv_yn;
    
    	Temperatura_Receita_ATUAL = Temperatura_receita_12;	//' ver receita 1
    	Receita_time_temp_ATUAL = R12_time_temp;		//' ver receita 1
    	
    	W_HDW5000 = 34;						//' Vai para a tela Receita_confirm
    }
    
    flag_Receita1_interm = false; 					//' zera bit flag
}

void TriggerBitBase::flagStartReceita()
{
    //flag_START_RECEITA
    //When flagStartReceita is called execute C++ code
    //Execute C++ code
    //''''''''''' MODO TEMPO
    
    Timer_Congelar_DECORRIDO_OUT = 0;						//' Zera bit Timer_decorrido_OUT
    
    if (Tempo_Receita_ATUAL == 0 && Receita_time_temp_ATUAL == 0) 	//' Confere se a receita não está com o tempo em zero no Modo Tempo
    	flag_alarm_receita_vazia = true;					//' flag alarme receita vazia = 1
    
    else{
    	if (Receita_time_temp_ATUAL == 0){				//' if Finalização Receita por Tempo
    		if (Receita_Cong_Resf_ATUAL == 0){ 			//'tela de COngelar TEMPO
    			W_HDW5000 = 3;
    			
    			Clear();
    			WriteModbus485(10242, 1);
    			WriteModbus485(10282, 1);
    			WriteModbus485(645, 1);
    				
    			Timer_SP_MINUTOS = Tempo_Receita_ATUAL; 			//' Coloca o valor so SP timer Minutos
    			Timer_Congelar_DECORRIDO_SP = Tempo_Receita_ATUAL * 6; 	//' TRansforma SP minutos em seg10
    	
    			Timer_Congelar_DECORRIDO_ON = 1;					//' START Timer TEmpo_COngelar_DECORRIDO_ON
    			flag_Processo_ANDAMENTO = 1;					//' Flag PRocesso_ANDAMENTO = TRUE
    			//@W_1:410242 = @SP_Congelar_Tempo				//' SP= SP Congelar Tempo
    			//@W_1:410282 = @Diferencial_Congelar_tempo			//' Diferencial rd Congelar Tempo
    			//@W_1:4645 = 1							//' Controlador em modo COntrole
    			
    			UpdateModbus485(10242, SP_Congelar_Tempo, _DOUBLE_);
    			UpdateModbus485(10242, SP_Congelar_Tempo, _DOUBLE_);
    			UpdateModbus485(10282, Diferencial_Congelar_tempo, _DOUBLE_);
    			UpdateModbus485(645, 1, _DOUBLE_);
    			
    			flag_Conservar_S_N = Receita_Conserv_ATUAL;			//' Atualiza se vai para conservação
    	
    			Status_tecla_Congela = 2; 						//' Aponta para status COngelar TEMPO
    		}
    	
    		if (Receita_Cong_Resf_ATUAL == 1){ 					//' tela de Resfriar TEMPO
    			
    			Clear();
    			WriteModbus485(10242, 1);
    			WriteModbus485(10282, 1);
    			WriteModbus485(645, 1);
    
    			flag_Resfriar_HARD_SOFT = Receita_Hard_Soft_ATUAL;		//' Indica se é Hard ou Soft na Receita
    			
    			Timer_SP_MINUTOS_Resfriar = Tempo_Receita_ATUAL; 		//' Coloca o valor do SP timer Minutos
    			Timer_Congelar_DECORRIDO_SP = Tempo_Receita_ATUAL * 6; 	//' TRansforma SP minutos em segx10
    
    			if (flag_Resfriar_HARD_SOFT == 0){				//'if SOFT
    				//@W_1:410242 =  @SP_SONDA_RESF_CAMARA				//' SP_controlador = SP Soft
    				SP_Resf_Hard_Interno_display = SP_Resfriar_Tempo_SOFT;
    				//@W_1:410282 = @Diferencial_Resfriar_Tempo			//' Diferencial rd
    				
    				UpdateModbus485(10242, SP_SONDA_RESF_CAMARA, _DOUBLE_);
    				UpdateModbus485(10242, SP_SONDA_RESF_CAMARA, _DOUBLE_);
    				UpdateModbus485(10282, Diferencial_Resfriar_Tempo, _DOUBLE_);
    			}
    			else{ //' HARD
    				Hard_Resf_fase_numero = 1; 					//' Resfriamento por etapas - Etapa =1
    
    				Dif_Resf_Hard_F1 = Diferencial_Resfriar_Tempo;
    				Dif_Resf_Hard_F2 = Dif_Resf_Hard_F1;
    
    				//@W_1:410242 = @SP_Resf_Interno_F1 
    				//@W_1:410282 = @Dif_Resf_Hard_F1					//' Diferencial de controle para modo Delicado Sonda
    				
    				UpdateModbus485(10242, SP_Resf_Interno_F1, _DOUBLE_);
    				UpdateModbus485(10242, SP_Resf_Interno_F1, _DOUBLE_);
    				UpdateModbus485(10282, Dif_Resf_Hard_F1, _DOUBLE_);
    	
    				SP_Resf_Hard_Interno_display =  SP_Resf_Interno_F1;
    						
    				Preset_Resf_Tempo_F1 = Timer_SP_MINUTOS_Resfriar * 6; 	//' transforma Sp minutos em seg*10
    				Preset_Resf_Tempo_F1 = Preset_Resf_Tempo_F1 * Porc_Resf_preset_tempo_F1F2;
    				Preset_Resf_Tempo_F1 = Preset_Resf_Tempo_F1 / 10;
    
    				Preset_Resf_Tempo_F2 = Timer_SP_MINUTOS_Resfriar * 6 - Preset_Resf_Tempo_F1;
    
    				SP_Resf_Interno_F2 = SP_SONDA_RESF_CAMARA;
    				xBeep_once = false;
    				
    			}
    	
    
    			//@W_1:4645 = 1					//' Controlador em modo COntrole
    			
    			UpdateModbus485(645, 1, _DOUBLE_);		
    
    			flag_Conservar_S_N = Receita_Conserv_ATUAL;	//'Atualiza se vai para conservação
    
    			Status_tecla_Congela = 4; 				//' Indica Resfriar TEMPO
    
    			Timer_Congelar_DECORRIDO_ON = 1;			//' START Timer TEmpo_COngelar_DECORRIDO_ON
    			flag_Processo_ANDAMENTO = true;			//' Flag PRocesso_ANDAMENTO = TRUE
    
    			W_HDW5000 = 13;					//' tela de Resfriar TEMPO
    		}
    	}
    	else{									//' @Receita_time_temp_ATUAL = 1 (modo finalização receita por Temperatura)
    		W_HDW5000 = 40;						//' Altera para tela Receita Temperatura		
    		
    		Clear();
    		WriteModbus485(10242, 1);
    		WriteModbus485(10282, 1);
    		WriteModbus485(645, 1);
    
    		if (Receita_Cong_Resf_ATUAL == 0){ 			//'
    			//@W_1:410242= @SP_SONDA_CONGELAR_CAMARA	//' SP = CONGELAR SONDA CAMARA
    			//@W_1:410282 = @Diferencial_Congelar_tempo	//' Diferencial rd=3ºC
    			
    			UpdateModbus485(10242, SP_SONDA_CONGELAR_CAMARA, _DOUBLE_);
    			UpdateModbus485(10242, SP_SONDA_CONGELAR_CAMARA, _DOUBLE_);
    			UpdateModbus485(10282, Diferencial_Congelar_tempo, _DOUBLE_);
    		}
    		else{
    			//@W_1:410242= @SP_SONDA_RESF_CAMARA		//' SP = RESFRIAR SONDA CAMARA
    			//@W_1:410282 = @Diferencial_Resfriar_Tempo	//' Diferencial rd
    			
    			UpdateModbus485(10242, SP_SONDA_RESF_CAMARA, _DOUBLE_);
    			UpdateModbus485(10242, SP_SONDA_RESF_CAMARA, _DOUBLE_);
    			UpdateModbus485(10282, Diferencial_Resfriar_Tempo, _DOUBLE_);
    		}
    
    
    		//@W_1:4645 = 1					//' Controlador em modo COntrole
    		
    		UpdateModbus485(645, 1, _DOUBLE_);		
    
    		Timer_Congelar_DECORRIDO_SP = 99999;		//' SP Timer- Inf
    		
    		Timer_Congelar_DECORRIDO_ON = 1;			//' START Timer TEmpo_COngelar_DECORRIDO_ON
    		flag_Processo_ANDAMENTO = true;			//' Flag PRocesso_ANDAMENTO = TRUE
    		
    		Timer_delay_ON = 1;					//' Start Timer Delay
    		
    		flag_Conservar_S_N = Receita_Conserv_ATUAL;	//' Atualiza se vai para conservação
    		
    
    		Status_tecla_Congela = 0;				//' Status_tecla_Congela = Modo Receita Temperatura
    				
    
    	}
    }
    
    
    flag_START_RECEITA = false;		//' zera bit flag
}

void TriggerBitBase::flagRedefineSenha()
{
    //flag_redefine_senha
    //When flagRedefineSenha is called execute C++ code
    //Execute C++ code
    W_HDW5000 = 37;			//' pagina para redefinir senha caso esquecido
    
    flag_redefine_senha = false;	//' zera bit de redefinição de senha
}

void TriggerBitBase::flagAlarmeExterno()
{
    //flag_alarme_externo
    //When flagAlarmeExterno is called execute C++ code
    //Execute C++ code
    if (flag_Processo_ANDAMENTO == 1){
    	if (Status_tecla_Congela == 0){ 			//' Modo COngelar Sonda
    		flag_Processo_ANDAMENTO = false; 		//' Zera flag_PROCESSO_ANDAMENTO
    		//@W_1:410242 = 999				//' SP = 99.9ºC
    		//@W_1:4645 = 0				//' Controlador em Stand-By
    		
    		UpdateModbus485(10242, 999, _DOUBLE_);
    		UpdateModbus485(10242, 999, _DOUBLE_);
    		UpdateModbus485(645, 0, _DOUBLE_);	
    				
    		Timer_Congelar_DECORRIDO_ON = 0;		//' Zera bit Timer_decorrido_ON	
    	}
    
    	if (Status_tecla_Congela == 1){			//' Modo COngelar Sonda
    		flag_Processo_ANDAMENTO = false; 		//' Zera flag_PROCESSO_ANDAMENTO
    		//@W_1:410242 = 999				//' SP = 99.9ºC
    		//@W_1:4645 = 0				//' Controlador em Stand-By
    		
    		UpdateModbus485(10242, 999, _DOUBLE_);	
    		UpdateModbus485(10242, 999, _DOUBLE_);
    		UpdateModbus485(645, 0, _DOUBLE_);		
    		
    		Timer_Congelar_DECORRIDO_ON = 0;		//' Zera bit Timer_decorrido_ON	
    	}
    
    	if (Status_tecla_Congela == 2){ 			//' Modo COngelar Tempo
    		flag_Processo_ANDAMENTO = false; 		//' Zera flag_PROCESSO_ANDAMENTO
    		//@W_1:410242 = 999				//' SP = 99.9ºC
    		//@W_1:4645 = 0				//' Controlador em Stand-By
    		
    		UpdateModbus485(10242, 999, _DOUBLE_);
    		UpdateModbus485(10242, 999, _DOUBLE_);
    		UpdateModbus485(645, 0, _DOUBLE_);
    		
    		Timer_Congelar_DECORRIDO_ON = 0;		//' Zera bit Timer_decorrido_ON	
    	}
    
    	if (Status_tecla_Congela == 3){ 			//' Modo Resfriar Sonda
    		flag_Processo_ANDAMENTO = false; 		//' Zera flag_PROCESSO_ANDAMENTO
    		//@W_1:4640 = 0				//' Desliga Modo Turbo
    		//@W_1:410242 = 999				//' SP = 99.9ºC
    		//@W_1:4645 = 0				//' Controlador em Stand-By
    
    		UpdateModbus485(640, 0, _DOUBLE_);
    		UpdateModbus485(10242, 999, _DOUBLE_);
    		UpdateModbus485(645, 0, _DOUBLE_);
    		
    		Timer_Congelar_DECORRIDO_ON = 0;		//' Zera bit Timer_decorrido_ON		
    	}
    
    	if (Status_tecla_Congela == 4){ 			//' Modo Resfriar Tempo
    		flag_Processo_ANDAMENTO = false; 		//' Zera flag_PROCESSO_ANDAMENTO
    		//@W_1:410242 = 999				//' SP = 99ºC
    		//@W_1:4645 = 0				//' Controlador em Stand-By
    		
    		UpdateModbus485(10242, 999, _DOUBLE_);
    		UpdateModbus485(10242, 999, _DOUBLE_);
    		UpdateModbus485(645, 0, _DOUBLE_);
    				
    		Timer_Congelar_DECORRIDO_ON = 0;		//' Zera bit Timer_decorrido_ON
    	}
    
    	flag_Processo_ANDAMENTO = false;
    }
    else{ 								//' if @flag_Processo_ANDAMENTO=0
    	if (Status_tecla_Congela == 1 || Status_tecla_Congela == 2){	//'if Congelar_SONDA ou Congelar_Tempo
    		W_HDW5000=1;							//' Tela_Congelar
    	}
    	else{						//' if @Status_tecla_Congela=3 or @Status_tecla_Congela=4
    		W_HDW5000=10;			//' Tela_Resfriar
    	}
    }
    
    if (flag_Conservar_ANDAMENTO == 1){
    	if (Status_Conservar == 1){		//' Conservar_Congelar
    		//@W_1:410242 = 999			//' SP = 99ºC
    		//@W_1:4645 = 0			//' Controlador em modo Standby
    		
    		UpdateModbus485(10242, 999, _DOUBLE_);
    		UpdateModbus485(10242, 999, _DOUBLE_);
    		UpdateModbus485(645, 0, _DOUBLE_);
    	}
    	
    	if (Status_Conservar == 2){ 		//' Consewrvar_Resfriar
    		//@W_1:410242 = 999			//' SP = 99ºC
    		//@W_1:4645 = 0			//' Controlador em modo Stand-by
    		
    		UpdateModbus485(10242, 999, _DOUBLE_);
    		UpdateModbus485(10242, 999, _DOUBLE_);
    		UpdateModbus485(645, 0, _DOUBLE_);
    	}
    	
    	flag_Conservar_ANDAMENTO = false;		//' Zera flag_conservar_andamento
    
    	Timer_buzzer_ON = 1;			//' inicia Timer_Buzzer
    }
    
    //' Cancelar Degelo
    if (flag_degelo_andamento == 1){
    
    	Status_degelo = 0;				//' Desliga Degelo
    	flag_degelo_andamento = false;		//' Flag degelo em andamento=0
    
    	//@W_1:410242 = 999				//' SP = 99ºC
    	//@W_1:4645 = 0					//' Controlador em modo Stand-BY
    	//@W_1:410256 = 2 * @logica_entrada_digital1	//' i.F1 = Entrada Digital 1 > Porta com parada ventilador (NA = porta fechada)
    	
    	UpdateModbus485(10242, 999, _DOUBLE_);
    	UpdateModbus485(10242, 999, _DOUBLE_);
    	UpdateModbus485(645, 0, _DOUBLE_);
    	UpdateModbus485(10256, 2 * logica_entrada_digital1, _DOUBLE_);	
    
    	Timer_degelo_delay_ON = 0;			//' Timer Degelo Delay ON = 0
    	Timer_degelo_delay_OUT = 0;		//' Timer_degelo_delay_OUT=0
    	Timer_Degelo_CONTROL = 0;			//' timer_degelo_control=0
    	Timer_Degelo_ON = 0;			//' Timer Degelo ON =0
    
    }
    
    
    Timer_delay_OUT = 0;			//' Zera Timer_delay_OUT
    
    Timer_buzzer_ON = 1;			//' inicia Timer_Buzzer
    
    W_HDW5000 = 38;				//' Vai para a tela de Alarme externo
    
    flag_alarme_externo_andamento = true;	//' Indica que já está em alarme externo
    
    flag_alarme_externo = false;		//' zera bit flag alarme externo
}

void TriggerBitBase::timerAlarmeExternoOut()
{
    //Timer_alarme_externo_OUT
    //When timerAlarmeExternoOut is called execute C++ code
    //Execute C++ code
    Timer_alarme_externo_ON = 0;		//' Reset temporizador alarme externo 
    
    flag_alarme_externo_andamento = 0;	//' Finaliza alarme externo depois da temporização
    
    
    W_HDW5000 = 0	;				//' Tela inicial
    
    Timer_alarme_externo_OUT = false;		//' zera bit timer alarme externo OUT
}

void TriggerBitBase::entradaDigital3()
{
    //Entrada_digital_3
    //When entradaDigital3 is called execute C++ code
    //Execute C++ code
    if (Estado_Redial_Receita == 1 && W_HDW5000 == 34){				//' if Estado Redial = 1
    	
    //''''''''''''''''''''''''''''
    	Timer_Congelar_DECORRIDO_OUT = 0;						//' Zera bit Timer_decorrido_OUT
    	
    	if (Tempo_Receita_ATUAL == 0 && Receita_time_temp_ATUAL == 0){ 	//' Confere se a receita não está com o tempo em zero no Modo Tempo
    		flag_alarm_receita_vazia = true;					//' flag alarme receita vazia = 1
    	}
    	else{
    		if (Receita_time_temp_ATUAL == 0){				//' if Finalização Receita por Tempo
    			if (Receita_Cong_Resf_ATUAL == 0){ 			//'tela de COngelar TEMPO
    				W_HDW5000 = 3;
    				
    				Clear();
    				WriteModbus485(10242, 1);
    				WriteModbus485(10282, 1);
    				WriteModbus485(645, 1);
    					
    				Timer_SP_MINUTOS = Tempo_Receita_ATUAL; 			//' Coloca o valor so SP timer Minutos
    				Timer_Congelar_DECORRIDO_SP = Tempo_Receita_ATUAL * 6; 	//' TRansforma SP minutos em seg10
    		
    				Timer_Congelar_DECORRIDO_ON = 1;					//' START Timer TEmpo_COngelar_DECORRIDO_ON
    				flag_Processo_ANDAMENTO = true;					//' Flag PRocesso_ANDAMENTO = TRUE
    				//@W_1:410242 = @SP_Congelar_Tempo				//' SP= SP Congelar Tempo
    				//@W_1:410282 = @Diferencial_Congelar_tempo			//' Diferencial rd Congelar Tempo
    				//@W_1:4645 = 1							//' Controlador em modo COntrole
    				
    				UpdateModbus485(10242, SP_Congelar_Tempo, _DOUBLE_);
    				UpdateModbus485(10242, SP_Congelar_Tempo, _DOUBLE_);
    				UpdateModbus485(10282, Diferencial_Congelar_tempo, _DOUBLE_);
    				UpdateModbus485(645, 1, _DOUBLE_);				
    
    				flag_Conservar_S_N = Receita_Conserv_ATUAL;			//' Atualiza se vai para conservação
    	
    				Status_tecla_Congela = 2; 						//' Aponta para status COngelar TEMPO
    			}
    	
    			if (Receita_Cong_Resf_ATUAL == 1){ 					//' tela de Resfriar TEMPO
    				W_HDW5000 = 13;							//' tela de Resfriar TEMPO
    				
    				Clear();
    				WriteModbus485(10242, 1);
    				WriteModbus485(10282, 1);
    				WriteModbus485(645, 1);
    
    				Timer_SP_MINUTOS_Resfriar = Tempo_Receita_ATUAL; 		//' Coloca o valor do SP timer Minutos
    				Timer_Congelar_DECORRIDO_SP = Tempo_Receita_ATUAL * 6; 	//' TRansforma SP minutos em segx10
    
    				Timer_Congelar_DECORRIDO_ON = 1;					//' START Timer TEmpo_COngelar_DECORRIDO_ON
    				flag_Processo_ANDAMENTO = 1;					//' Flag PRocesso_ANDAMENTO = TRUE
    	
    				flag_Resfriar_HARD_SOFT = Receita_Hard_Soft_ATUAL;		//' Indica se é Hard ou Soft na Receita
    
    				if (flag_Resfriar_HARD_SOFT == false){				//'if SOFT
    					//@W_1:410242 = @SP_Resfriar_Tempo_SOFT			//' SP_controlador = SP Soft
    					UpdateModbus485(10242, SP_Resfriar_Tempo_SOFT, _DOUBLE_);
    					UpdateModbus485(10242, SP_Resfriar_Tempo_SOFT, _DOUBLE_);
    				}
    				else{
    					//@W_1:410242 = @SP_Resfriar_Tempo_HARD			//' SP_controlador = SP HARD 
    					UpdateModbus485(10242, SP_Resfriar_Tempo_HARD, _DOUBLE_);
    					UpdateModbus485(10242, SP_Resfriar_Tempo_HARD, _DOUBLE_);
    				}
    	
    				//@W_1:410282 = @Diferencial_Resfriar_Tempo			//' Diferencial rd=3ºC
    				//@W_1:4645 = 1								//' Controlador em modo COntrole
    				
    				UpdateModbus485(10282, Diferencial_Resfriar_Tempo, _DOUBLE_);
    				UpdateModbus485(645, 1, _DOUBLE_);				
    
    				flag_Conservar_S_N = Receita_Conserv_ATUAL;			//'Atualiza se vai para conservação
    
    				Status_tecla_Congela = 4; 						//' Indica Resfriar TEMPO
    			}
    		}
    		else{											//' @Receita_time_temp_ATUAL = 1 (modo finalização receita por Temperatura)
    			W_HDW5000 = 40;								//' Altera para tela Receita Temperatura		
    			
    			Clear();
    			WriteModbus485(10242, 1);
    			WriteModbus485(10282, 1);
    			WriteModbus485(645, 1);
    			
    			if (Receita_Cong_Resf_ATUAL == 0){ 			//'
    				//@W_1:410242= @SP_SONDA_CONGELAR_CAMARA	//' SP = CONGELAR SONDA CAMARA
    				//@W_1:410282 = @Diferencial_Congelar_tempo	//' Diferencial rd=3ºC
    				
    				UpdateModbus485(10242, SP_SONDA_CONGELAR_CAMARA, _DOUBLE_);
    				UpdateModbus485(10242, SP_SONDA_CONGELAR_CAMARA, _DOUBLE_);
    				UpdateModbus485(10282, Diferencial_Congelar_tempo, _DOUBLE_);
    			}
    			else{
    				//@W_1:410242= @SP_SONDA_RESF_CAMARA		//' SP = RESFRIAR SONDA CAMARA
    				//@W_1:410282 = @Diferencial_Resfriar_Tempo	//' Diferencial rd
    				
    				UpdateModbus485(10242, SP_SONDA_RESF_CAMARA, _DOUBLE_);
    				UpdateModbus485(10242, SP_SONDA_RESF_CAMARA, _DOUBLE_);
    				UpdateModbus485(10282, Diferencial_Resfriar_Tempo, _DOUBLE_);
    			}
    
    
    
    
    			//@W_1:4645 = 1				//' Controlador em modo COntrole
    			
    			UpdateModbus485(645, 1, _DOUBLE_);			
    
    			Timer_Congelar_DECORRIDO_SP = 99999;	//' SP Timer- Inf
    			
    			Timer_Congelar_DECORRIDO_ON = 1;		//' START Timer TEmpo_COngelar_DECORRIDO_ON
    			flag_Processo_ANDAMENTO = true;		//' Flag PRocesso_ANDAMENTO = TRUE
    		
    			Timer_delay_ON = 1;				//' Start Timer Delay
    		
    			flag_Conservar_S_N = Receita_Conserv_ATUAL;	//' Atualiza se vai para conservação
    		
    
    			Status_tecla_Congela = 0;				//' Status_tecla_Congela = Modo Receita Temperatura
    		}
    	}
    
    
    //'	@flag_START_RECEITA = 0		//' zera bit flag		
    
    
    //'''''''''''''''''''''''''''''
    
    	Estado_Redial_Receita = 0;
    }
    
    
    
    
    if (flag_Processo_ANDAMENTO == false && flag_Conservar_ANDAMENTO == false && flag_degelo_andamento == false && flag_alarme_externo_andamento == false && flag_hab_desab_Tecla_REDIAL == true){ //' Se processos desativados
    	if (numero_receita == 1 || numero_receita == 2 || numero_receita == 3 || numero_receita == 4){	//' Se Receita de 1 a 4
    		flag_Receita1_interm = true;										//' Flag para descarregar os dados da receita															
    	}
    	if (numero_receita == 5 || numero_receita == 6 || numero_receita == 7 || numero_receita == 8){	//' Se Receita de 5 a 8
    		flag_Receita2_interm = true;										//' Flag para descarregar os dados da receita																
    	}
    	if (numero_receita == 9 || numero_receita == 10 || numero_receita == 11 || numero_receita == 12){	//' Se Receita de 5 a 8
    		flag_Receita3_interm = true;										//' Flag para descarregar os dados da receita																
    	}	
    	
    	Estado_Redial_Receita = 1;											//' Estado Redial = 1
    }
}

void TriggerBitBase::confereSenha()
{
    //Confere_senha
    //When confereSenha is called execute C++ code
    //Execute C++ code
    if (Senha_Gravada == Senha_usuario){
    	W_HDW5000 = 6;
    }
    
    Senha_usuario = 0;		//' reseta senha usuário
    
    Confere_senha = false;
}

void TriggerBitBase::resetFabrica()
{
    //reset_fabrica
    //When resetFabrica is called execute C++ code
    //Execute C++ code
    	Status_tecla_Congela = 1;			//' MODO CONGELAR SONDA
    	Timer_SP_MINUTOS = 120;			//' Inicia com timer em 120 min CONGELAR TEMPO
    	Timer_SP_MINUTOS_Resfriar = 120;		//' Inicia com timer em 120 min RESFRIAR TEMPO
    	
    	
    	SP_Conservar_Congelar =-250;		//' SP Conservar_Congelar=-25ºC		
    	Diferencial_Conservar_COngelar = 50;	//' Diferencial_conservar_Congelar
    
    	SP_Conservar_Resfriar = 30; 		//' Setpoiint Conservar_resfriar = 3.0
    	Diferencial_Conservar_Resfriar = 50; 	//' Diferencial_conservar_resfriar=5.0
    
    	CONGELAR_SONDA_SP = -180;			//' SP modo COngelar SONDA
    
    	SP_Congelar_Tempo = -400;			//' SP congelar TEmpo
    	Diferencial_Congelar_tempo = 50;		//' Diferencial congelar Tempo
    
    	SP_Resfriar_Sonda = 40; 			//' SP Resfriar modo SOnda = 4.0ºC
    
    	SP_Resfriar_Tempo_SOFT = -20;		//' SP Tempo SOFT = -2.0
    	SP_Resfriar_Tempo_HARD = -20;		//' SP Tempo HARD  = -2.0
    	Diferencial_Resfriar_Tempo = 50;		//' Diferencial Tempo = 5.0ºC
    	
    	logica_entrada_digital1 = 1;		//' Logica da entrada digital (1 normal / -1 invertido)
    	logica_entrada_digital2 = 1;		//' Logica da entrada digital (1 normal / -1 invertido)
    
    	//@W_1:410294 = 1				//' Ventilador ligado durante Degelo
    	//@W_1:410256 = 1				//' i.F1 = Door Open "1"
    
    	//@W_1:410256 = 2				//' i.F1 = Entrada Digital 1 > Porta com parada ventilador (NA = porta fechada)
    	//@W_1:410258 = 5				//' i.F2 = Entrada Digital 2 > Alarme externo com desativação das saídas
    	
    	//@W_1:410324 = 0				//' Desativa buzzer do controlador
    
    	UpdateModbus485(10294, W_1_410294 = 1, _DOUBLE_);
    	UpdateModbus485(10256, W_1_410256 = 1, _DOUBLE_);
    	UpdateModbus485(10256, W_1_410256 = 2, _DOUBLE_);
    	UpdateModbus485(10258, W_1_410258 = 5, _DOUBLE_);
    	UpdateModbus485(10324, W_1_410324 = 0, _DOUBLE_);
    
    	timer_alarme_externo_SP_MINUTOS = 1;					//' Tempo de retorno do alarme externi (min)
    	Timer_Alarme_externo_SP = timer_alarme_externo_SP_MINUTOS * 6;	//' Retorno do alarme em 1 minuto
    
    	//@W_HAW8214 = "Alarme de Tensao"		//' Descrição do alarme externo
    	//@W_HAW8235 = "Consultar manual"
    
    	strcpy(W_HAW8214, "Alarme de Tensao");
    	strcpy(W_HAW8235, "Consultar manual");
    
    	flag_hab_desab_Tecla_REDIAL = 0;		//' Tecla Redial desabilitado
    
    	//@W_1:410255 = 5				//' i.p4 = Entrada Digital 4
    	UpdateModbus485(10255, W_1_410255 = 5, _DOUBLE_);
    
    	Senha_Gravada = 123;			//' Senha Inicial = 123
    
    	//@W_1:410294 = 0					//' Ventilador desligado durante o degelo
    	UpdateModbus485(10294, W_1_410294 = 0, _DOUBLE_);
    
    	degelo_porta_aberta = false;			//' degelo entra independente da porta
    	//@B_1:410265.0 = TRUE 				//' Degelo por gas quente
    	
    	SetBitModbusRS485("10265.0", 1);	
    
    	degelo_processo_automatico = false;		//' após término do degelo, Não inicia ultimo processo automaticamente
    	//@W_1:410270 = 1000				//' Duração do degelo 10.00 minutos
    	//@W_1:410279 = 1000				//' Duração do pós degelo (gotejamento) 10.00 minutos
    	//@W_1:410295 = 1003				//' Retardo para ativação do evaporador após o degelo 10 minutos e 3 segundos
    
    	UpdateModbus485(10270, W_1_410270 = 1000, _DOUBLE_);
    	UpdateModbus485(10279, W_1_410279 = 1000, _DOUBLE_);
    	UpdateModbus485(10295, W_1_410295 = 1003, _DOUBLE_);	
    
    	SP_SONDA_CONGELAR_CAMARA = -250;			//' Setpoint da Camara no modo CONGELAR Sonda
    	SP_SONDA_RESF_CAMARA = 0;				//' Setpoint da Camara no modo RESFRIAR Sonda 
    	
    
    	SP_Resf_Interno_F1 = -250;					//' SP interno de resfriamento modo HARD - FAse 1
    	Dif_Resf_Hard_F1 = Diferencial_Resfriar_Tempo;		//' Diferencial interno de resfriamento modo HARD - FAse 1
    	SP_Resf_Espeto_F1 = 150;					//' SP ESpeto de resfriamento modo HARD - Troca FAse 1 para Fase 2	
    
    	SP_Resf_Interno_F2 = SP_SONDA_RESF_CAMARA;		//' SP interno de resfriamento modo HARD - FAse 1
    	Dif_Resf_Hard_F2 = Diferencial_Resfriar_Tempo;		//' Diferencial interno de resfriamento modo HARD - FAse 1	
    	SP_Resf_Espeto_F2 = SP_Resfriar_Sonda;			//' SP ESpeto de resfriamento modo HARD - Finalização
    
    	Porc_Resf_preset_tempo_F1F2 = 6;   			//' Porcentagem /10 do tempo total do ciclo de refriamento 60% fase 1 > 40% fase 2
    	
    	//' RECEITA
    	Tempo_receita_1 = 120;
    	Tempo_receita_2 = 120;
    	Tempo_receita_3 = 120;
    	Tempo_receita_4 = 120;
    	Tempo_receita_5 = 120;
    	Tempo_receita_6 = 120;
    	Tempo_receita_7 = 120;
    	Tempo_receita_8 = 120;
    	Tempo_receita_9 = 120;
    	Tempo_receita_10 = 120;
    	Tempo_receita_11 = 120;
    	Tempo_receita_12 = 120;
    
    
    reset_fabrica = false;
}

void TriggerBitBase::startHigiene()
{
    //start_higiene
    //When startHigiene is called execute C++ code
    //Execute C++ code
    Clear();
    WriteModbus485(10242, 1);
    WriteModbus485(10322, 1);
    WriteModbus485(645, 1);
    
    //@W_1:410242=999		//' SP = 999ºC
    //@W_1:4645 = 1		//' Controlador em modo COntrole
    
    //@W_1:410322 = 11 		//' oo3 = on
    
    UpdateModbus485(10242, 999, _DOUBLE_);
    UpdateModbus485(10242, 999, _DOUBLE_);
    UpdateModbus485(645, 1, _DOUBLE_);
    UpdateModbus485(10322, 11, _DOUBLE_);
    
    timer_higiene_ON = true;
    
    status_higiene = true;
    
    
    W_HDW5000 = 45;		//' Altera para tela de HIGIENE
    
    
    start_higiene = false;
}

void TriggerBitBase::cancelaHigiene()
{
    //cancela_higiene
    //When cancelaHigiene is called execute C++ code
    //Execute C++ code
    Clear();
    WriteModbus485(10242, 1);
    WriteModbus485(645, 1);
    WriteModbus485(10322, 1);
    
    
    //@W_1:410242 = 999		//' SP = 99ºC
    //@W_1:4645 = 0		//' Controlador em modo Stand-BY
    
    //@W_1:410322 = 3 		//' oo3 = Fn
    
    UpdateModbus485(10242, 999, _DOUBLE_);
    UpdateModbus485(10242, 999, _DOUBLE_);
    UpdateModbus485(645, 0, _DOUBLE_);
    UpdateModbus485(10322, 3, _DOUBLE_);
    
    timer_higiene_ON = false;
    
    status_higiene = false;
    
    W_HDW5000 = 44;		//' Altera para tela de HIGIENE	
    
    
    cancela_higiene = false;
}

void TriggerBitBase::changeScreen(uint16_t value)
{
    //ChangeScreen
    //When changeScreen is called execute C++ code
    //Execute C++ code
    W_HDW5000 = value;
    
    switch(value)
    {
    	case 0: hScreen.action0(); break;
    	case 1: hScreen.action1(); break;
    	case 2: hScreen.action2(); break;
    	case 3: hScreen.action3(); break;
    	case 4: hScreen.action4(); break;
    	case 6: hScreen.action6(); break;
    	case 7: hScreen.action7(); break;
    	case 8: hScreen.action8(); break;
    	case 9: hScreen.action9(); break;
    	case 10: hScreen.action10(); break;
    	case 11: hScreen.action11(); break;
    	case 12: hScreen.action12(); break;
    	case 13: hScreen.action13(); break;
    	case 14: hScreen.action14(); break;
    	case 15: hScreen.action15(); break;
    	case 17: hScreen.action17(); break;
    	case 18: hScreen.action18(); break;
    	case 19: hScreen.action19(); break;
    	case 20: hScreen.action20(); break;
    	case 21: hScreen.action21(); break;
    	case 22: hScreen.action22(); break;
    	case 23: hScreen.action23(); break;
    	case 24: hScreen.action24(); break;
    	case 25: hScreen.action25(); break;
    	case 26: hScreen.action26(); break;
    	case 27: hScreen.action27(); break;
    	case 28: hScreen.action28(); break;
    	case 29: hScreen.action29(); break;
    	case 30: hScreen.action30(); break;
    	case 31: hScreen.action31(); break;
    	case 32: hScreen.action32(); break;
    	case 33: hScreen.action33(); break;
    	case 34: hScreen.action34(); break;
    	case 36: hScreen.action36(); break;
    	case 37: hScreen.action37(); break;
    	case 38: hScreen.action38(); break;
    	case 39: hScreen.action39(); break;
    	case 40: hScreen.action40(); break; 
    	case 42: hScreen.action42(); break;
    	case 43: hScreen.action43(); break;
    	case 44: hScreen.action44(); break;
    	case 45: hScreen.action45(); break;
    	case 47: hScreen.action47(); break;
    	case 999: hScreen.action999(); break;
    }
}

void TriggerBitBase::flagInicilizarAplicacao()
{
    //flag_Inicilizar_APLICACAO
    //When flagInicilizarAplicacao is called execute C++ code
    //Execute C++ code
    flag_Inicilizar_APLICACAO = false;
    
    // Inicialização Controlador
    
    UpdateModbus485(641, W_1_4641 = 0, _DOUBLE_);		// Degelo OFF
    UpdateModbus485(645, W_1_4645 = 0, _DOUBLE_);		// Inicializa controlador em Stand-by
    UpdateModbus485(10242, W_1_410242 = 999, _DOUBLE_);	// SP = 99.9ºC
    
    
    // Inicializações gerais
    
    W_HSW9 = 1; 					// Desativa msg de timeout
    
    
    Timer_Congelar_DECORRIDO_ON = 0;		// Timer_Congelar_decorrido_ON
    Timer_Congelar_DECORRIDO_OUT = 0;		// Timer_Congelar_decorrido_OUT
    
    Timer_buzzer_SP = 4;			// Timer Buzzer 4seg
    W_HAW8000 = 0;				// Timer_Congelar_COUNT = 0
    Timer_COUNT_MINUTOS = 0;			// Timer_Congelar_COUNT_minutos = 0
    
    Timer_Delay_SP = 1;				// Timer Delay SP
    
    Timer_Degelo_SP = 9999;			// Timer SP
    Timer_degelo_delay_SP = 5;			// Timer_degelo_delay_SP = 1 seg
    
    
    
    UpdateModbus485(10322, W_1_410322 = 3, _DOUBLE_);	// oo3 = Fn
    UpdateModbus485(10323, W_1_410323 = 0, _DOUBLE_);	// Inicia OUT4 = oF
    
    
    
    numero_receita = 1; 	// Inicia na Receita 1
    
    
    
    if (initial_value == 0) 
    {
    	Status_tecla_Congela = 1;			// MODO CONGELAR SONDA
    	Timer_SP_MINUTOS = 1;			// Inicia com timer em 1 min CONGELAR TEMPO
    	Timer_SP_MINUTOS_Resfriar = 1;		// Inicia com timer em 1 min RESFRIAR TEMPO
    	
    	
    	SP_Conservar_Congelar =-250;		// SP Conservar_Congelar=-25ºC		
    	Diferencial_Conservar_COngelar = 30;	// Diferencial_conservar_Congelar
    
    	SP_Conservar_Resfriar = 30; 		// Setpoiint Conservar_resfriar = 3.0
    	Diferencial_Conservar_Resfriar = 20; 	// Diferencial_conservar_resfriar=2.0
    
    	CONGELAR_SONDA_SP =- 180;			// SP modo COngelar SONDA
    
    	SP_Congelar_Tempo = -400;			// SP congelar TEmpo
    	Diferencial_Congelar_tempo = 30;		// Diferencial congelar Tempo
    
    	SP_Resfriar_Sonda = 20; 			// SP Resfriar modo SOnda = 2.0ºC
    
    	SP_Resfriar_Tempo_SOFT = -200;		// SP Tempo SOFT
    	SP_Resfriar_Tempo_HARD = -400;		// SP Tempo HARD
    	Diferencial_Resfriar_Tempo = 30;		// Diferencial Tempo = 2.0ºC
    	
    	logica_entrada_digital1 = 1;		// Logica da entrada digital (1 normal / -1 invertido)
    	logica_entrada_digital2 = 1;		// Logica da entrada digital (1 normal / -1 invertido)
    	
    	
    	UpdateModbus485("10294", W_1_410294 = 1, _DOUBLE_);		// Ventilador ligado durante Degelo
    	UpdateModbus485("10256", W_1_410256 = 1, _DOUBLE_);		// i.F1 = Door Open "1"
    
    //	UpdateModbus485("10299", W_1_410299 = 2, _DOUBLE_);		// P.od = Start delay Compressor protection disabled
    	UpdateModbus485("10256", W_1_410256 = 2, _DOUBLE_);		// i.F1 = Entrada Digital 1 > Porta com parada ventilador (NA = porta fechada)
    	UpdateModbus485("10258", W_1_410258 = 5, _DOUBLE_);		// i.F2 = Entrada Digital 2 > Alarme externo com desativação das saídas
    	
    	UpdateModbus485("324", W_1_4324 = 0, _DOUBLE_);		// Desativa buzzer do controlador
    
    	timer_alarme_externo_SP_MINUTOS = 1;	// Tempo de retorno do alarme externi (min)
    	Timer_Alarme_externo_SP = timer_alarme_externo_SP_MINUTOS * 6;	// Retorno do alarme em 1 minuto
    	
    	
    	//W_HAW8214 = "Alarme de Tensao"		// Descrição do alarme externo
    	//W_HAW8235 = "Consultar manual"
    
    	strcpy(W_HAW8214, "Alarme de Tensao\0");
    	strcpy(W_HAW8235, "Consultar manual\0");
    
    	flag_hab_desab_Tecla_REDIAL = 0;			// Tecla Redial desabilitado
    
    	UpdateModbus485("10255", W_1_410255 = 5, _DOUBLE_);		// i.p4 = Entrada Digital 4
    
    	Senha_Gravada = 123;				// Senha Inicial = 123
    
    	UpdateModbus485("10294", W_1_410294 = 0, _DOUBLE_);		// Ventilador desligado durante o degelo
    	degelo_porta_aberta = false;			// degelo entra independente da porta
    	
    	SetBitModbusRS485("10265.0", 1); 			// Degelo por gas quente
    	
    	degelo_processo_automatico = false;		// após término do degelo, Não inicia ultimo processo automaticamente
    	UpdateModbus485("10270", W_1_410270 = 1000, _DOUBLE_);			// Duração do degelo 10.00 minutos
    	UpdateModbus485("10279", W_1_410279 = 1000, _DOUBLE_);			// Duração do pós degelo (gotejamento) 10.00 minutos
    	UpdateModbus485("10295", W_1_410295 = 1003, _DOUBLE_);			// Retardo para ativação do evaporador após o degelo 10 minutos e 3 segundos
    
    	SP_SONDA_CONGELAR_CAMARA = -250;		// Setpoint da Camara no modo CONGELAR Sonda
    	SP_SONDA_RESF_CAMARA = 0;			// Setpoint da Camara no modo RESFRIAR Sonda 
    
    	SP_Resf_Interno_F1 = -250;				// SP interno de resfriamento modo HARD - FAse 1
    	Dif_Resf_Hard_F1 = Diferencial_Resfriar_Tempo;	// Diferencial interno de resfriamento modo HARD - FAse 1
    	SP_Resf_Espeto_F1 = 150;				// SP ESpeto de resfriamento modo HARD - Troca FAse 1 para Fase 2	
    
    	SP_Resf_Interno_F2 = SP_SONDA_RESF_CAMARA;	// SP interno de resfriamento modo HARD - FAse 1
    	Dif_Resf_Hard_F2 = Diferencial_Resfriar_Tempo;	// Diferencial interno de resfriamento modo HARD - FAse 1	
    	SP_Resf_Espeto_F2 = SP_Resfriar_Sonda;		// SP ESpeto de resfriamento modo HARD - Finalização
    
    	Porc_Resf_preset_tempo_F1F2 = 6;   		// Porcentagem /10 do tempo total do ciclo de refriamento 60% fase 1 > 40% fase 2
    
    	// RECEITA
    	Tempo_receita_1 = 120;
    	Tempo_receita_2 = 120;
    	Tempo_receita_3 = 120;
    	Tempo_receita_4 = 120;
    	Tempo_receita_5 = 120;
    	Tempo_receita_6 = 120;
    	Tempo_receita_7 = 120;
    	Tempo_receita_8 = 120;
    	Tempo_receita_9 = 120;
    	Tempo_receita_10 = 120;
    	Tempo_receita_11 = 120;
    	Tempo_receita_12 = 120;
    
    // Inicializar mensagem "sem receita"
    	
    }
    
    // Inicialização Controlador
    
    UpdateModbus485(641, W_1_4641 = 0, _DOUBLE_);		// Degelo OFF
    UpdateModbus485(645, W_1_4645 = 0, _DOUBLE_);		// Inicializa controlador em Stand-by
    UpdateModbus485(10242, W_1_410242 = 999, _DOUBLE_);	// SP = 99.9ºC
    
    

    //Carregar_Receitas
    //When flag_Inicilizar_APLICACAO completed execute C++ code
    //Execute C++ code
    SelectJob(0);
    ReadJobName(Receita_1_desc);
    R1_time_temp			= ReadJobData(3, _INT_) != 0 ? true : false;
    Tempo_receita_1		= ReadJobData(1, _INT_);
    Temperatura_receita_01 	= 10.0 * ReadJobData(2, _FP_32BIT_);
    R1_cong_resf			= ReadJobData(4, _INT_) != 0 ? true : false;
    R1_Hard_Soft			= ReadJobData(6, _INT_) != 0 ? true : false;
    R1_Conserv_yn			= ReadJobData(7, _INT_) != 0 ? true : false;
    
    SelectJob(1);
    ReadJobName(Receita_2_desc);
    R2_time_temp			= ReadJobData(3, _INT_) != 0 ? true : false;
    Tempo_receita_2		= ReadJobData(1, _INT_);
    Temperatura_receita_02 	= 10.0 * ReadJobData(2, _FP_32BIT_);
    R2_cong_resf			= ReadJobData(4, _INT_) != 0 ? true : false;
    R2_Hard_Soft			= ReadJobData(6, _INT_) != 0 ? true : false;
    R2_Conserv_yn			= ReadJobData(7, _INT_) != 0 ? true : false;
    
    SelectJob(2);
    ReadJobName(Receita_3_desc);
    R3_time_temp			= ReadJobData(3, _INT_) != 0 ? true : false;
    Tempo_receita_3		= ReadJobData(1, _INT_);
    Temperatura_receita_03 	= 10.0 * ReadJobData(2, _FP_32BIT_);
    R3_cong_resf			= ReadJobData(4, _INT_) != 0 ? true : false;
    R3_Hard_Soft			= ReadJobData(6, _INT_) != 0 ? true : false;
    R3_Conserv_yn			= ReadJobData(7, _INT_) != 0 ? true : false;
    
    SelectJob(3);
    ReadJobName(Receita_4_desc);
    R4_time_temp			= ReadJobData(3, _INT_) != 0 ? true : false;
    Tempo_receita_4		= ReadJobData(1, _INT_);
    Temperatura_receita_04 	= 10.0 * ReadJobData(2, _FP_32BIT_);
    R4_cong_resf			= ReadJobData(4, _INT_) != 0 ? true : false;
    R4_Hard_Soft			= ReadJobData(6, _INT_) != 0 ? true : false;
    R4_Conserv_yn			= ReadJobData(7, _INT_) != 0 ? true : false;
    
    SelectJob(4);
    ReadJobName(Receita_5_desc);
    R5_time_temp			= ReadJobData(3, _INT_) != 0 ? true : false;
    Tempo_receita_5		= ReadJobData(1, _INT_);
    Temperatura_receita_05 	= 10.0 * ReadJobData(2, _FP_32BIT_);
    R5_cong_resf			= ReadJobData(4, _INT_) != 0 ? true : false;
    R5_Hard_Soft			= ReadJobData(6, _INT_) != 0 ? true : false;
    R5_Conserv_yn			= ReadJobData(7, _INT_) != 0 ? true : false;
    
    SelectJob(5);
    ReadJobName(Receita_6_desc);
    R6_time_temp			= ReadJobData(3, _INT_) != 0 ? true : false;
    Tempo_receita_6		= ReadJobData(1, _INT_);
    Temperatura_receita_06 	= 10.0 * ReadJobData(2, _FP_32BIT_);
    R6_cong_resf			= ReadJobData(4, _INT_) != 0 ? true : false;
    R6_Hard_Soft			= ReadJobData(6, _INT_) != 0 ? true : false;
    R6_Conserv_yn			= ReadJobData(7, _INT_) != 0 ? true : false;
    
    SelectJob(6);
    ReadJobName(Receita_7_desc);
    R7_time_temp			= ReadJobData(3, _INT_) != 0 ? true : false;
    Tempo_receita_7		= ReadJobData(1, _INT_);
    Temperatura_receita_07 	= 10.0 * ReadJobData(2, _FP_32BIT_);
    R7_cong_resf			= ReadJobData(4, _INT_) != 0 ? true : false;
    R7_Hard_Soft			= ReadJobData(6, _INT_) != 0 ? true : false;
    R7_Conserv_yn			= ReadJobData(7, _INT_) != 0 ? true : false;
    
    SelectJob(7);
    ReadJobName(Receita_8_desc);
    R8_time_temp			= ReadJobData(3, _INT_) != 0 ? true : false;
    Tempo_receita_8		= ReadJobData(1, _INT_);
    Temperatura_receita_08 	= 10.0 * ReadJobData(2, _FP_32BIT_);
    R8_cong_resf			= ReadJobData(4, _INT_) != 0 ? true : false;
    R8_Hard_Soft			= ReadJobData(6, _INT_) != 0 ? true : false;
    R8_Conserv_yn			= ReadJobData(7, _INT_) != 0 ? true : false;
    
    SelectJob(8);
    ReadJobName(Receita_9_desc);
    R9_time_temp			= ReadJobData(3, _INT_) != 0 ? true : false;
    Tempo_receita_9		= ReadJobData(1, _INT_);
    Temperatura_receita_09 	= 10.0 * ReadJobData(2, _FP_32BIT_);
    R9_cong_resf			= ReadJobData(4, _INT_) != 0 ? true : false;
    R9_Hard_Soft			= ReadJobData(6, _INT_) != 0 ? true : false;
    R9_Conserv_yn			= ReadJobData(7, _INT_) != 0 ? true : false;
    
    SelectJob(9);
    ReadJobName(Receita_10_desc);
    R10_time_temp			= ReadJobData(3, _INT_) != 0 ? true : false;
    Tempo_receita_10		= ReadJobData(1, _INT_);
    Temperatura_receita_10 	= 10.0 * ReadJobData(2, _FP_32BIT_);
    R10_cong_resf			= ReadJobData(4, _INT_) != 0 ? true : false;
    R10_Hard_Soft			= ReadJobData(6, _INT_) != 0 ? true : false;
    R10_Conserv_yn		= ReadJobData(7, _INT_) != 0 ? true : false;
    
    SelectJob(10);
    ReadJobName(Receita_11_desc);
    R11_time_temp			= ReadJobData(3, _INT_) != 0 ? true : false;
    Tempo_receita_11		= ReadJobData(1, _INT_);
    Temperatura_receita_11 	= 10.0 * ReadJobData(2, _FP_32BIT_);
    R11_cong_resf			= ReadJobData(4, _INT_) != 0 ? true : false;
    R11_Hard_Soft			= ReadJobData(6, _INT_) != 0 ? true : false;
    R11_Conserv_yn		= ReadJobData(7, _INT_) != 0 ? true : false;
    
    SelectJob(11);
    ReadJobName(Receita_12_desc);
    R12_time_temp			= ReadJobData(3, _INT_) != 0 ? true : false;
    Tempo_receita_12		= ReadJobData(1, _INT_);
    Temperatura_receita_12 	= 10.0 * ReadJobData(2, _FP_32BIT_);
    R12_cong_resf			= ReadJobData(4, _INT_) != 0 ? true : false;
    R12_Hard_Soft			= ReadJobData(6, _INT_) != 0 ? true : false;
    R12_Conserv_yn		= ReadJobData(7, _INT_) != 0 ? true : false;
    

    //Carregar_Configuracao
    //When Carregar_Receitas completed execute C++ code
    //Execute C++ code
    AddLocalNumberMemory(&CONGELAR_SONDA_SP);
    AddLocalNumberMemory(&SP_SONDA_CONGELAR_CAMARA);
    AddLocalNumberMemory(&SP_Congelar_Tempo);
    AddLocalNumberMemory(&Diferencial_Congelar_tempo);
    AddLocalNumberMemory(&SP_Conservar_Congelar);
    AddLocalNumberMemory(&Diferencial_Conservar_COngelar);
    AddLocalNumberMemory(&SP_Conservar_Resfriar);
    AddLocalNumberMemory(&Diferencial_Conservar_Resfriar);
    AddLocalNumberMemory(&timer_alarme_externo_SP_MINUTOS);
    AddLocalNumberMemory(&SP_Resf_Espeto_F1);
    AddLocalNumberMemory(&SP_Resf_Interno_F1);
    AddLocalNumberMemory(&SP_Resfriar_Sonda);
    AddLocalNumberMemory(&SP_SONDA_RESF_CAMARA);
    AddLocalNumberMemory(&Diferencial_Resfriar_Tempo);
    AddLocalNumberMemory(&Porc_Resf_preset_tempo_F1F2);
    
    HSW4 = GetBooleanMemory(50);
    // flag_hab_desab_Tecla_REDIAL = GetBooleanMemory(51);
    degelo_porta_aberta = GetBooleanMemory(52);
    degelo_processo_automatico = GetBooleanMemory(53);
    
    ReadDataMemory(W_HAW8214, 54, 20);
    ReadDataMemory(W_HAW8235, 57, 20);
    
    EnableSoundBuzzer(HSW4);
}

void TriggerBitBase::timerBuzzerDegOut()
{
    //Timer_BUzzer_DEG_OUT
    //When timerBuzzerDegOut is called execute C++ code
    //Execute C++ code
    if (degelo_processo_automatico == false){
    
    	//@W_1:4645 = 0				//' Controlador em modo Stand-BY
    	//@W_1:410323 = 0				//' OUT4 = oF
    	
    	UpdateModbus485(645, 0, _DOUBLE_);
    	UpdateModbus485(10323, 0, _DOUBLE_);
    
    	Timer_BUzzer_DEG_OUT = false;			//' zera bit flag
    	Timer_buzzer_DEG_ON = false;			//' zera bit flag
    }
    else{
    
    //''''''' Cancelar Degelo
    	Status_degelo = 0;			    		//' Desliga Degelo
    	flag_degelo_andamento = false; 			//' Flag degelo em andamento=0
    	
    	//@W_1:410256 = 2 * @logica_entrada_digital1	//' i.F1 = Entrada Digital 1 > Porta com parada ventilador (NA = porta fechada)
    	//@W_1:410299 = @delay_comp			//' POD = oF
    	
    	UpdateModbus485(10256, 2 * logica_entrada_digital1, _DOUBLE_);
    	UpdateModbus485(10299, delay_comp, _DOUBLE_);
    
    	Timer_degelo_delay_ON = 0;				//' Timer Degelo Delay ON = 0
    	Timer_degelo_delay_OUT = 0;			//' Timer_degelo_delay_OUT=0
    	Timer_Degelo_CONTROL = 0;				//' timer_degelo_control=0
    	Timer_Degelo_ON = 0;				//' Timer Degelo ON =0
    	Timer_Degelo_OUT = 0;
    
    //''''''''''  
    
    	if (Status_tecla_Congela == 1) 		//'CONGELAR SONDA
    		flag_congelar_SONDA = true;
    
    	
    	if (Status_tecla_Congela == 2 || Status_tecla_Congela == 4)	//'CONGELAR TEMPO ou RESFRIAR TEMPO
    		flag_congelar_Tempo = true;
    
    
    	if (Status_tecla_Congela == 3) 		//'RESFRIAR SONDA
    		flag_resfriar_Sonda_tempo = true;
    
    
    	if (Status_tecla_Congela == 0) 		//'RECEITA TEMPERATURA
    		flag_START_RECEITA = true;
    
    
    
    	//@W_1:410323 = 0			//' OUT4 = oF
    	UpdateModbus485(10323, 0, _DOUBLE_);
    
    	Timer_BUzzer_DEG_OUT = false;		//' zera bit flag
    	Timer_buzzer_DEG_ON = false;		//' zera bit flag
    
    }
}

void TriggerBitBase::timerBuzzerDegOn()
{
    //Timer_Buzzer_DEG_ON
    //When timerBuzzerDegOn is called execute C++ code
    //Execute C++ code
    //Beep()
    
    SoundBuzzerOn(100);
    
    //@W_1:410323 = 11		'OUT4 o4f = on
    
    UpdateModbus485(10323, 11, _DOUBLE_);
}

